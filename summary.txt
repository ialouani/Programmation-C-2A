Inventeur du C++: Bjarne Stroustrup.
Classes et instanciation d'objets: principe du poo.
En poo, une p=fonction virtuelle en 198x est une fonction définie dans une classe(méthode)~pointeur de fonction dans une structure C qui est destinée à être  redéfinie dans les classes qui en héritent(plus avancé ce concept).
Pour surcharger un opérateur, une fonction d’opérateur spéciale est définie dans la classe comme suit:
class MaClass
{
    ..................
    public
       returnType operator symbol (arguments)
       {
           ..................
       } 
    ..................
};
=>Ici, returnType est le type de retour de la fonction.
Le type de retour de la fonction est suivi du mot clé operator.
symbole est le symbole de l’opérateur que vous souhaitez surcharger. Exemple: +, <, -, ++, etc.
Vous pouvez transmettre des arguments à la fonction operator de la même manière que des fonctions classiques.
Ce sont juste des notions à savoir en premier ; pas plus. 
Normes:
1998: Normalisation du C++ par l’ISO (International Organization for
Standardization) et ANSI ISO/CEI 14882:1998
2003: Dernière version 14882:2003
2011: Dernière version 14882:2011
2014: mise à jour mineure ISO/CEI 14882:2014
2017: ISO/IEC 14882:2017
2020: en cours
Le but du C++(les fonctions virutelles pour définir les fonctions qui vont être héritées par les classes;la surcharge des opérateurs par l'ajout de nouvelles fonctionnalitées sous forme public entrée espace returnType operateur sylbol (arguments) ; l'inventeur bien sûr et le but ci-dessus):
Historique du language C++===(javasript)C+java. (orientée objets).//
=============================================================================================

L’ajout de fonctionnalités permettant la mise en oeuvre de concepts objets
dans le language C:
l’objet: attributs(données internes)(issus des classes(instanciation(javascript exemples))) + méthodes (comportements) ((comment ça marche tout cela)
encapsulation.(terme vu en prog. fonctionnelle qui permet d'encapsuler une partie privée qui consiste en une implémentation pour en masquer la partie publique qui est accesible à tout le monde ; concept plus avancée en C++ pas simplement un interface piblique et une modularité visant à mettre en oeuvre la modularité et la réutilisabilité du code)
Typage des objets.(type statique - dynamique, etc..)
Polymorphisme: un objet peut avoir plus d’un type.(important, le type d'un objet est pluôt générique, le type d'un objet instancié peut varié comme une fonctionnalitée héritée d'un prototype modèle d'objet en javascript)
redéfinition.(très important, les classes sont mutables différence avec les charactères suivies en javascript dans un simple programme)
classe: description et génération des objets.=>=>instanciaation et notion d'héritage.
<=>Il permet aussi la programmation générique: écriture de fonctions (et
d’objets) indépendantes du type de ces arguments. C’est l’idée du “code à
trous”.(écriture d'une fonction qui peut prendre un nombre fini de type=>généricité=>conclusion de la 1ere classe de la programmation fonctionnelle illustrée en javascript)
==============================================================================================
Est ce que tout programme C compile en C++
file.c on peut faire g++ file.c ?
Source C qui ne compile pas (invalidité synatxique) pas en C++.
Le C autorise la conversion implicite de void* en n'importe quel type de pointeur. 
exemple:
int* i=malloc(4);






**********************************************************************************
2ieme point: L'historique puis l'Alocation::
Au cours de l'éxécution, on peut réserver la mémoire soit via une bibliothéque dynamique présente sur la page de ressources, soit via le tas/la pile/le segment de données soit 4.
1)Allocation automatique (via le tas (géné par le programme tout seul au cours de l'EXECUTION))
On rappelle les motivations du C++:
-les fonctions virtuelles (plus que les pointeurs dans des structures)
-Surchage des opérateurs.(typage variant(générécité(on va voir comment(polymorphisme(classe générique)))))
Principaes à retenir:
=>fonctions virtuelles définissant des méthodes de classe.
=>la surcharge des opérateurs définisssant la généricité des classes via le polymorphisme.
2)Allocation dynamique:(le TAS)
En C++, elle se fait à l'aide de l'opérateur new.
On distingue deux types:
(à oublier les autres objectifs ; ils sont triviaux)
l'allocation d'un objet ; l'allocation d'un tableau d'objets.
new int;//allouer une place mémoire dans le tas référécant un entier.
new int[10];//allouer une place mémoire dans le tas référencant des sizeof(int) octes dans le tas.
Conclusion et perte de confusion:
l'opérateur new retourne l'adresse de début de cette zone.
et de meme pour le tableau d'objets.
On a deja demontre que toute variable en poo est considere comme un obejt tel quel.
Free<=>deleteen C++.
Les prototypes de libération de l'utilisateur de mémoire:
delete(new int);
delete[](new int[10]);
EXEMPLE COMPLET:
int* i=new int;//important pour maitriser la syntaxe.
int *t=new int[10];
delete i;
delete[] t;
2 allocations et bien non!
4, 2 automatiques pointeur de pointeur et deux dynamiques.
=>MODELISATION DE L'ETAT DE LA PILE ET DU TAS:
la pile est croissante vers le haut:
démarrons depuis le bas:
121 adresse arbitraire correspondant au stockage d'une donnée (pointeur de pointeur par exemple(int* t=new t[10] ou bien le plus simple va stocker en cette adresse l'adresse i) ; donc de 121 à 120 (normalement sur une machine à 32 bits ; ca se remet sur 4 blocks chacun d'un octet) puis 120 puis une démarche astuciseuse de 116 puis de 112:
0 non adressé. 
00
00
0A//65
02//2
différence 63 61 puis 1 non adressé en écriture ni en lecture. (NULL)
de meme pour l'autre block de 4.
Le tas:
A02 puis A010 les blocks de 8 deux tableaux: décalement d'adresses.
*********************************************************************************************

Les CLASSES:
rappel: C++ ::
fonctions virtuelles et généricité des classes.
historique: créateur et ce qu'il y a avant.
reste: les allocations::
la pile; les tas (rappels (dl))::
rappels:
=>int *i=new int;(int *t=new int t[10])
=>free en C++: delete[] t;//pour faire un free du tableau en question.(delete seulement en cas de faire un free)
**********************************************************************************************




Les classes:
C'est le coeur de la programmation objet.
1)Définition et déclaration:
une classe consiste en un regroupement de méthpdes et d'attributs.
Exemple:
class NomClasse{
attributes
...
méthodes
...
};
=>EXEMPLES:::
L'ordre des déclarations ne compte pas.
Le classe:
#ifndef POINT_H
#define POINT_H
class Point
{
public:
void setX(double x);
void setY(double y);
double getX();
double getY();
double distance(const Point &P);
Point milieu(const Point &P);
void saisir();
void afficher();//interface accessibilité
private:
double x,y;//données d'accessiblité d'héritage via des objets (en vue de l'avancée)
};
#endif
La classe est une description des données internes et comportements qu'aura une instance généré par cette classe.
Les classes: instanciation::
=>L'instanciation(vue de la généricité) ou (réification), c'est à dire la création d'un objet innstance (ressource) à partir de l'objet classe (description/générateur) peut se faire de façon dynamique. 
--allocation dynamique:
A *a=new A();//type *A a pointeur allouée dynamiquement via new A() <=> via new (int* a= new int) A() correspond à une fonction qui retourne un new int qui fait une allocation dynamique en C++. 
--allocation automatique:
A a; //en A a type A declaration de variable a. Voila.
Une classe ; on rappelle ; est une description des données internes et comportements qu'aura une instance générée par cette classe.
2)Les classes: INSTANCIATION:



LA RéIFICATION est la création d'un objet instance (ressource) à partir de l'objet classe (descrption/generateur) peut se faire de manière dynamique: 
tas: A *a=new A();
pile: A a;
pile:
A a
deja expliquées d'une façcon détaillée.
=>=>=>Dans les deux cas, une ressource(adresse mémoire) est associée à l'instance. Dans la ressource du tas(les adresses allouées), cette ressource est située dans le tas bien sûr, dans le cas automatique, elle est située (la variable en question) dans la pile.
3)Visibilité,friend,struct:
Resumé jusqu'à là:
Le cours du chapitre 11 : Les classes
Une évolution des structures
Une fois introduite la notion de structures, on s'aperçoit qu'il est totalement naturel de créer des fonctions permettant de manipuler ces structures. La notion de classe est donc une notion plus puissante que la notion de structures. Une classe va permettre de regrouper en une seule entité des données membres et des fonctions membres appelées méthodes.
Cependant, contrairement au langage C, les structures du C++ permettent cela également. La différence entre une structure et une classe est que les attributs et méthodes d'une structure sont par défaut publics, alors qu'ils sont par défaut privés dans une classe(deja immplementation pas d'interface dispo pour une instanciation). Une autre différence est que les structures ne peuvent utiliser l'héritage.(et ça c'est moins..///)
Notion de classe
Une classe regroupera donc :
• des données membres.
• des méthodes membres qui seront des fonctions.
Un premier exemple de classe
• On veut manipuler des points définis par une abscisse et une ordonnée (des réels).
• Sur un point, on peut calculer la distance entre 2 points et le milieu de 2 points.
• Nous allons donc définir une classe Point définie par un fichier .h et un fichier .cpp.
VOIR FICHIER Point.h.
Explications
On définit dans ce fichier la classe Point : elle contient 2 données de type double x et y et 2 méthodes membres distance qui calcule la distance entre ce point et un autre Point et milieu qui calcule le milieu du segment composé de
ce point et d'un autre Point. On remarque l'utilisation des directives de compilation #ifndef, #define et #endif pour gérer les inclusions multiples du fichier header.
Explications
Programmation C++ (débutant)/Les classes 2
Explications
On définit dans ce fichier la classe Point : elle contient 2 données de type double x et y et 2 méthodes membres
distance qui calcule la distance entre ce point et un autre Point et milieu qui calcule le milieu du segment composé de
ce point et d'un autre Point.
On remarque l'utilisation des directives de compilation #ifndef, #define et #endif pour gérer les inclusions multiple
du fichier header.
Le fichier Point.cpp:
#include "Point.h"
#include <cmath>
double Point::distance(const Point &P)
{
double dx,dy;
dx = x - P.x;
dy = y - P.y;
return sqrt(dx*dx + dy*dy);
}
Point Point::milieu(const Point &P)
{
Point M;
M.x = (P.x+x) /2;
M.y = (P.y+y) /2;
return M;
}
EXPLICATIONS IMPORTANTES ET FONDAMENTALES:
Explications
• Il contient l'implémentation de chaque méthode de la classe Point.
//des deux fonctions de manipulations rendues publiques avec le mot public: entrée.
• On fait précéder chaque méthode de Point::
//synatxe obligeatoire ; rappel: Point Point::milieu(const Point &P){..}
• On a inclut le fichier cmath afin de pouvoir utiliser la fonction sqrt de cmath (racine carrée).//cmath en C++ et math.h en C.
=>LE TOUT EN MAIN.cpp:::::
• A l'intérieur de la classe Point, on peut accéder directement à l'abscisse du point en utilisant la donnée membre x.//c'est ça car rendu publique.
• On peut accéder à l'abscisse du paramètre P d'une méthode en utilisant P.x.
//comme la syntaxe de C.Explications
• Une fois inclus le fichier d'en-tête Point.h, on peut définir 3 points A, B et C.
• A, B et C sont 3 objets qui sont des instances de la classe Point.
• Les données membres étant publiques, on peut accéder à l'abscisse et à l'ordonnée de A en dehors de la classe en
écrivant A.x et A.y.
• Les méthodes membres distance et milieu étant publiques, on peut écrire directement A.milieu(B) ou
A.distance(B).
On revient au cours de allali:
count<<"L'abcisse vaut<<scin>>A.x
//retour à la ligne; count << endl
count <<"Le milieu vaut en terme d'abcisse du point en question" << C.X <<endl
//de meme pour l'ordoonée*
count<<endl.
Voilà.
On définit un fichier Point.h qui va contenir la définition des classes qu'on va instancier; ici Point. Ca sera Point.h. Puis le fichier Point.cpp est la partie privée qui contenera(plusieurs parties privées possibles) l'implémentation des méthodes fonctions des classes de Point.h, et dernièrement le fichier main.cpp qui va être compilé avec Point.c qui inclut le fichier Point.h évidement qui va faire un main en instanciant trois objets A,B,C en disant en quoi consiste leurs coordonées puis faire A.milieu(B) pour calculer le milieu entre A et B ; c'est simple.//
============================================================
On contrôle l’accès aux méthodes et attributs pour une sous-classe ou un objet
exterieur avec public,protected et private:
la classe sous-classe exterieur
public oui oui oui
protected oui oui non
private oui non non
Remarque: Les membres protected et private ne peuvent être accédés qu’à
partir d’une fonction membre de l’instance
deja expliquée (dechargement du pc//via main2.cpp et le make file target lance ment2).
Programmation C++ (débutant)/Les classes 4
3)(je semble que je suis pas trompé de numéro)Interface et boîte noire:
• Vu de l'extérieur, on ne peut accéder à un objet donné que grâce à ces méthodes publiques.
• Ceci permet entre autre de protéger l'intégrité des données.
• L'ensemble des méthodes publiques est appelée l'interface de l'objet.
• De l'extérieur, l'objet peut être vu comme une boîte noire qui possède une interface d'accès.
• On cache ainsi à l'utilisateur de cette classe comment cette interface est implémentée : seul le comportement de
l'interface est important.
4)Accesseurs et mutateurs
• On pourra accéder aux valeurs des données membres privées grâce à des méthodes spécifiques appelée accesseurs(this;getX;modifiction via setX;etc..). Les accesseurs seront publics.
• On pourra même modifier ces valeurs grâce à des fonctions spécifiques appelées mutateurs.
A se rappeler: les mutateurs sont des fonctions qui peuvent y accéder à la partie privée via des accesseurs et en muter le contenu courant modérament.
• Cela permet au programmeur d'avoir un contrôle complet sur ces données et sur des contraintes en tout genre qu'il veut imposer à ces données.
Voilà.
===============================================================
5)Explications plus logiques et pertinentes:
Programmation C++ (débutant)/Les classes 6
void Point::saisir()
{
cout << "Tapez l'abscisse : "; cin >> x;
cout << "Tapez l'ordonnée : "; cin >> y;
}
void Point::afficher()
{
cout << "L'abscisse vaut " << x << endl;
cout << "L'abscisse vaut " << y << endl;
}
Explications
• Dans la méthode setX(...), il y a une utilisation du mot-clé this. Le mot clé this désigne un pointeur vers l'instance courante de la classe elle même(la sous-classe). this->x désigne donc la donnée membre de la classe alors que x désigne le paramètre de la méthode void setX(double x);(c'est logique, l'approfondissement en programmation prototype nous a permis de nous renseigner dune façcon pertinente et compréhensible sur moi-même)
• Le mutateur double getX(); se contente de renvoyer la valeur de x.
LE FAIT DE DECLARER LA FONCTION comme etant appartenant a la classe Point et de faire retourner x ; le compilateur sait qu'il doit renvoyer le x de l'objet classe'' en quESTION.
6)détails disons supplémentaires:
Explications:
• On n'a plus le droit d'accéder aux données membres x et y sur les instances de Point A, B et C en utilisant A.x ou B.y : il faut obligatoirement passer là une des méthodes publiques.
<=>main2.cpp ### main.cpp.
• Pour saisir la valeur de A, il suffit d'écrire A.saisir();
• Pour afficher la valeur de A, il suffit d'écrire A.afficher();
L'encpasulation dans l'approche objet permet de rendre publique que les fonctionnalitées qui permettent via un main tout simple d'accéder aux différents contenus de la sous-classe elle-même ; le fait de ne pas accéder à la donnée membre donnée directement affirme qu'on amsque et on rend privée une partie de 'linterface', c'est le principe d'encapsulation. En approche fonctionnelle, l'encapsulation permet de rendre inacessible certaines fonctionnalitées automatiquement executées au sein d'un module au profit de l'autre modularité qui permet grâce à l'abstraction de multiplier les implémentations de de faire de la modularité tout en respectant les tests et varier les structures et lancer le même objectifs tout en laissant au testeur logiciel le feu vert tout en lançcant ses propres tests d'avant.
==============================================================================
====================================================================================







Programmation C++ (débutant)/Les classes 7
Explications
• On n'a plus le droit d'accéder aux données membres x et y sur les instances de Point A, B et C en utilisant A.x ou
B.y : il faut obligatoirement passer là une des méthodes publiques.
• Pour saisir la valeur de A, il suffit d'écrire A.saisir();
• Pour afficher la valeur de A, il suffit d'écrire A.afficher();
Exécution(rappels d'avant important à retenir ; la programmation en java c'est le clone de cette explication ecrite et tres bien ecrite)
Lorsqu'on exécute ce programme, il s'affiche à l'écran :
SAISIE DU POINT A
Tapez l'abscisse : 3.2
Tapez l'ordonnée : 1.4
SAISIE DU POINT B
Tapez l'abscisse : 5
Tapez l'ordonnée : 6
MILIEU DE AB
L'abscisse vaut : 4.1
L'ordonnée vaut : 3.7
La distance AB vaut : 4.93964
Utiliser les opérateurs >> et <<
• Pour pouvoir saisir un Point au clavier, on pourrait écrire tout simplement cin >> A; où A est une instance de la(pas >>;cin A mais bien: cin>> A; avec un espace c'est preferable comme << endl)
classe Point.
• Pour écrire un Point à l'écran, on peut écrire tout simplement cout << B.
• Nous allons utiliser pour cela les fonctions operator>> et operator<<.
• Dans l'exemple 3, on utilisera une manière de procéder assez personnelle sans utiliser de fonctions amies;
• Dans l'exemple 4, nous verrons la méthode qui semble plus classique basée sur les fonctions amies.
=>les fonctions amies pas virtuelles (ce qu'on a vu jusqu'à là):::
<=>RAPPEL GLOBAL:Explications
• On n'a plus le droit d'accéder aux données membres x et y sur les instances de Point A, B et C en utilisant A.x ou
B.y : il faut obligatoirement passer là une des méthodes publiques.
• Pour saisir la valeur de A, il suffit d'écrire A.saisir();
• Pour afficher la valeur de A, il suffit d'écrire A.afficher();
Exécution
Lorsqu'on exécute ce programme, il s'affiche à l'écran :
SAISIE DU POINT A
Tapez l'abscisse : 3.2
Tapez l'ordonnée : 1.4
SAISIE DU POINT B
Tapez l'abscisse : 5
Tapez l'ordonnée : 6
MILIEU DE AB
L'abscisse vaut : 4.1
L'ordonnée vaut : 3.7
La distance AB vaut : 4.93964
Utiliser les opérateurs >> et <<
• Pour pouvoir saisir un Point au clavier, on pourrait écrire tout simplement cin >> A; où A est une instance de la
classe Point.
• Pour écrire un Point à l'écran, on peut écrire tout simplement cout << B.
• Nous allons utiliser pour cela les fonctions operator>> et operator<<.
• Dans l'exemple 3, on utilisera une manière de procéder assez personnelle sans utiliser de fonctions amies;
• Dans l'exemple 4, nous verrons la méthode qui semble plus classique basée sur les fonctions amies
On définit dans la partie publique les operateurs fonctionnels soit les deux fonctions classiques d'entrée et de sortie comme stdio.h..:::
void operator>>(ostream &out) car partant vers la donnée inscrite en memory systel.
void operator<<(istream &int) car entran a retenir le mot: istream et C++ plus compliqué=>ostream pour la sortie.(moyen mneothechique).
AVEC CELA; on lieu de faire un scanf avec:
count << "entrez l'abscisse du premier point parmi les deux a choisir" >> cin ; << endl; 
on va faire tout simpelment une implementation de operateur<<(isotrem &out) et istream(&in) via le fichier Point3.cpp qui implémnet la partie publique de l'interface'':
On reprend la même synatxe: 
void Point..RQ: void afficher() ne prend rien en parametre car liée à la classe elle même pas comme milieu qui necessite une autre sous classe pour manipuler les deux.$
Revenons à nos prioritées:
void isotream(&out) sera implémentée dans la partie privée de l'implémenbtation interface GLOBALE via:
on garde la même procédure de déclaration de fonction:
void Point:operator>>(isotream &out)
{
out << "L'abcisse vaut" << x << endl" tout simple comme un printf mais son utilisation dans le main dans le fichier main3.cpp diffère:
il suffit après (rappel) de faire out << "L'abcisse vaut" << x << endl (x refere à this->x dans l'instance du main definie par la sous classe Point A,B,C(C representant le rslt))
1->afficher ce qu'on veut dire : cout << "SAISIE DU POINT A" << endl puis A << cin le contraire c'est l'objet A qui va rentrer dans le systeme car le isotrem>> et istream<< gere tout cela. Puis un simple A << endl NON count(le mot clef a mettre entete) count << endl (espace de preference ; code PROPRE) pour revenir a la ligne suivante evidemment.
VOILà.
Une autre méthode pour des scnaf et la mise en oeuvre du principe d'necpasulation par la modification de 'linterface en classe portant des membres fonctionnelles publiques permettant d'y acdéder discrètement aux membres données privées de l'interface''''' en question.
========================
====================================
======================================================================
Programmation C++ (débutant)/Les classes 9
return 0;
}
Explications :
On peut directement saisir les coordonnées d'un point par A<<cin ou l'afficher à l'écran par A>>cout.
Exécution :
Lorsqu'on exécute ce programme, il s'affiche à l'écran :
SAISIE DU POINT A
Tapez l'abscisse : 3.2
Tapez l'ordonnée : 1.4
SAISIE DU POINT B
Tapez l'abscisse : 5
Tapez l'ordonnée : 6
MILIEU DE AB
L'abscisse vaut : 4.1
L'ordonnée vaut : 3.7
La distance AB vaut : 4.93964
La notation A<<cout
• On peut attacher l'opérateur de << à la classe Point comme dans l'exemple 3.
• Certains préfèrent toutefois écrire de manière plus usuelle : cout<<A;petit rappel:
std::count<<A permet d'afficher la variable A que ce qoit une adresse ou non avec sans retour à la ligne.
• Ils argumentent parfois en disant qu'en plus cela permet d'enchaîner les affichages en écrivant :
cout<<A<<endl<<B;//c'est possible A saut à la ligne puis B syntaxe nouvellement ajoutée dans les derneires versions du compilateurs des fichiers .cpp(g++)
• Il faudrait donc normalement définir une méthode operator<<(const Point &A) sur la classe
ostream.
• Or la classe iostream est déjà écrite !//c'est ca le probleme ; la synataxe y est:
void operator>>(isotrem &in)
Les fonctions amies
• Pour pouvoir écrire cout<<A; il faut écrire une fonction ostream & operator<<(ostream &,
const Point &P);
• Le plus pratique est que cette fonction ait le droit d'accéder aux données membres privées de la classe Point.
• On va donc la créer en tant que fonction amie en utilisant le mot-clé friend.
• L'abus de fonctions amies rompt avec le principe d'encapsulation : à utiliser avec précaution.//c'est le problème que tout le monde ne peut pas cacher ; si plusieurs utilisateurs se permettent de modifier l'instanciation de la classe via differentes fonctionnalitées comme affichage avec saut a la ligne ou sans , alors c'est pas rompu.
********************************************
6)(je crois que me suis pas trompé en terme de nombre):::
Elles renvoient respectivement une référence vers un istream et un ostream pour pouvoir enchaîner par exemple :
cout<<A<<B(suite des commentaires de Point4.h).
=================
Explications
• Nos 2 fonctions renvoient respectivement in et out par une instruction return afin de pouvoir enchaîner les
opérations de saisie et d'affichage.
• cout ne modifie pas notre Point : on passe donc une référence vers un Point constant.
• Pour cin, il faut passer en paramètre une référence vers un Point.
On va tout comprendre dans le MAIN4.CPP.
voir main4.cpp et surtout le fichier POint4.CPP pour comprendre  la logique du systeme.
=>inititiation au developpement en ce qui concerne la compilation(matiere) et le domaine abstrait de la programmation systeme.

























=============================================================================================
2ieme partie du cours:























































