1-Ouvrir un projet simple de hello world en C++:
iostream: codage standard avec using namespace std pour que count << qui permet d'avoir une fonction soit mieux que std::count qui est une methode de iostream interface d'entree(clavier) de sortie(processeur) de l'user.

2-Passage par reference ; un nouveau passage d'objets en C++:
int swap(int *a, int *b) avec celle-ci on passe des &e &d avec d et e des entiers pour inverser leurs places en memoire ainsi le deferencement de e tout a la fin correspondrait a la valeur de e, ici en C++ c'est asticueix; on mélange minitieusement les trucs:
void swap (int & a, int & b)
avec a=10 et b=20 mais FAIT PENSER A L'ADRESSE.<=>pointeur mais pas de gestion de syntaxe de pointeur=>int e,d; swapR(e,d) tout simple ; lui se debrouille ; on l'indique simplement implicitement tout simplement. 
=>AVANCE: valeur de retour par reference:
int & mini(const int & a, const int & b){
###int & a  <=> int* a mais pas *a valeur et a adresse
###sauf manipulation comme passage en valeurs.
return const_cast<int &> (a < b ? a:b);
}
On stocke le resultat dans un rslt de type int & ca veut dire que la valeur minimale va etre referencee via la variable declaree evaluative avec la fonction construite. Du coup le resultat disons second qui a ete change vua le changeemnt de result via rslt++ va modifier le block de reference (comme poi tage vers le lien et modification) second mais une min normalement avec des int va incrementer le rslt pour test mais non pas du tout incrementer la variabe dont elle est cause car ona pas declare une reference, on a declare une variable entiere qui va avoir sa propre adresse avec le resultat independANT trouve.

3-Surcharges de fonctions et d'opérateurs:
l'utilisation de plusieurs fonctions ayant le meme prototype non pas forcément est possible avec le meme nom surtout sur C++ mais ca doit etre bien geree!!!
attention dans la plupart de cas ils sont de type retour void et affiche avec std::cont<< ... << sndl; avec des parametres relationnels pointeurs ou valeurs..///
Voilà mais le three.cpp va développer cela trop.
rappel: count <=> extern ostream cout.////
=>resume de cette meilleure instructive partie:
ON VEUT afficher les donnees d'une structure C++ contenant 100 données ; le classique est de faire une longue ligne ;  mais l'astuce est de surcharger l'opérateur p.(via une fonction 'virtuelle'). on peut declarer le début de cout<<p comme un ostream & os cad. un flux d'affichage en double chainage de reference d'execution continue avec la donnée qu'on va retourner pour remettre les termes a zero. A l'interieur le flux demarre de os ainsi on ecrira: os << p.first << p.second << .. << p.hundrend sans <<endl qui va etre linkée à la chose: <<endl. par retour de os on pointe vers le dernier charactère d'où l'utilité de surcharger les fonctions pour utiliser une variete de fonctions de meme nom sans erreurs pour les classes et la derniere chose surcharge des operateurs pour factoriser un affuchage ; c'est le but des operateurs << de type ostream & qui signifie des flux pas des donnees fixes.

4)Fonctions << inline >>
-eviter les macros paramtrees
-dans un .h declaration et implementation si inline plusieurs .h dans un seul cpp recevant les.
-pas gros: degrader la taille de l'executable.
-de petites calculs et surtout quand on a fait de l'objet. 

5)Fonctions namespaces:
depuis le projet courant pourquoi pas.



